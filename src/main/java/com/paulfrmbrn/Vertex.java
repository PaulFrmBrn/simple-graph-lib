package com.paulfrmbrn;

import javax.annotation.Nonnull;
import javax.annotation.concurrent.Immutable;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;

import static java.util.Objects.requireNonNull;

/**
 * Represent the Vertex of the {@link Graph}
 * Stores vertex id and value (payload)
 *
 * {@link Vertex#id} is autogenerated
 *
 * Equality, hashing and comparision for the instance is based on {@link Vertex#id} value only, so {@link Vertex#value} is ignored
 *
 * @author Dmitry Pavlov
 * @since 30.05.2020
 */
@Immutable
public class Vertex<T> implements Comparable<Vertex<T>> {

    private static final AtomicInteger idGenerator = new AtomicInteger();

    private final int id;
    private final T value;

    private Vertex(int id, @Nonnull T value) {
        this.id = id;
        this.value = requireNonNull(value, "value");
    }

    public static <T> Vertex<T> of(T value) {
        return new Vertex<>(idGenerator.incrementAndGet(), value);
    }

    public int getId() {
        return id;
    }

    @Nonnull
    public T getValue() {
        return value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Vertex)) return false;
        Vertex<?> vertex = (Vertex<?>) o;
        return getId() == vertex.getId();
    }

    @Override
    public int hashCode() {
        return Objects.hash(getId());
    }

    @Override
    public int compareTo(Vertex<T> that) {
        return Integer.compare(this.getId(), that.getId());
    }

    @Override
    public String toString() {
        return "'" + value + "'{" + id + "}";
    }
}
